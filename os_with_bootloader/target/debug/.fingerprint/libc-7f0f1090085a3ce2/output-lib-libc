{"$message_type":"diagnostic","message":"extern declarations without an explicit ABI are deprecated","code":{"code":"missing_abi","explanation":null},"level":"warning","spans":[{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":9378,"byte_end":9384,"line_start":260,"line_end":260,"column_start":36,"column_end":42,"is_primary":true,"text":[{"text":"                pub $($constness)* extern fn $i($($arg: $argty),*) -> $ret","highlight_start":36,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/mod.rs","byte_start":55101,"byte_end":55588,"line_start":1506,"line_end":1521,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"safe_f! {","highlight_start":1,"highlight_end":10},{"text":"    // It seems htonl, etc are macros on macOS. So we have to reimplement them. So let's","highlight_start":1,"highlight_end":89},{"text":"    // reimplement them for all UNIX platforms","highlight_start":1,"highlight_end":47},{"text":"    pub {const} fn htonl(hostlong: u32) -> u32 {","highlight_start":1,"highlight_end":49},{"text":"        u32::to_be(hostlong)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    pub {const} fn htons(hostshort: u16) -> u16 {","highlight_start":1,"highlight_end":50},{"text":"        u16::to_be(hostshort)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    pub {const} fn ntohl(netlong: u32) -> u32 {","highlight_start":1,"highlight_end":48},{"text":"        u32::from_be(netlong)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    pub {const} fn ntohs(netshort: u16) -> u16 {","highlight_start":1,"highlight_end":49},{"text":"        u16::from_be(netshort)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"safe_f!","def_site_span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":9061,"byte_end":9080,"line_start":252,"line_end":252,"column_start":9,"column_end":28,"is_primary":false,"text":[{"text":"        macro_rules! safe_f {","highlight_start":9,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"`#[warn(missing_abi)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"explicitly specify the C ABI","code":null,"level":"help","spans":[{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":9378,"byte_end":9384,"line_start":260,"line_end":260,"column_start":36,"column_end":42,"is_primary":true,"text":[{"text":"                pub $($constness)* extern fn $i($($arg: $argty),*) -> $ret","highlight_start":36,"highlight_end":42}],"label":null,"suggested_replacement":"extern \"C\"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/mod.rs","byte_start":55101,"byte_end":55588,"line_start":1506,"line_end":1521,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"safe_f! {","highlight_start":1,"highlight_end":10},{"text":"    // It seems htonl, etc are macros on macOS. So we have to reimplement them. So let's","highlight_start":1,"highlight_end":89},{"text":"    // reimplement them for all UNIX platforms","highlight_start":1,"highlight_end":47},{"text":"    pub {const} fn htonl(hostlong: u32) -> u32 {","highlight_start":1,"highlight_end":49},{"text":"        u32::to_be(hostlong)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    pub {const} fn htons(hostshort: u16) -> u16 {","highlight_start":1,"highlight_end":50},{"text":"        u16::to_be(hostshort)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    pub {const} fn ntohl(netlong: u32) -> u32 {","highlight_start":1,"highlight_end":48},{"text":"        u32::from_be(netlong)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    pub {const} fn ntohs(netshort: u16) -> u16 {","highlight_start":1,"highlight_end":49},{"text":"        u16::from_be(netshort)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"safe_f!","def_site_span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":9061,"byte_end":9080,"line_start":252,"line_end":252,"column_start":9,"column_end":28,"is_primary":false,"text":[{"text":"        macro_rules! safe_f {","highlight_start":9,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: extern declarations without an explicit ABI are deprecated\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs:260:36\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m260\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  pub $($constness)* extern fn $i($($arg: $argty),*) -> $ret\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: explicitly specify the C ABI: `extern \"C\"`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/mod.rs:1506:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1506\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0msafe_f! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1507\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    // It seems htonl, etc are macros on macOS. So we have t\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1508\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    // reimplement them for all UNIX platforms\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1509\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub {const} fn htonl(hostlong: u32) -> u32 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1521\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(missing_abi)]` on by default\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `safe_f` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"extern declarations without an explicit ABI are deprecated","code":{"code":"missing_abi","explanation":null},"level":"warning","spans":[{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":8865,"byte_end":8871,"line_start":246,"line_end":246,"column_start":43,"column_end":49,"is_primary":true,"text":[{"text":"                pub $($constness)* unsafe extern fn $i($($arg: $argty),*) -> $ret","highlight_start":43,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/linux_like/mod.rs","byte_start":56826,"byte_end":58289,"line_start":1614,"line_end":1660,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"f! {","highlight_start":1,"highlight_end":5},{"text":"    pub fn CMSG_FIRSTHDR(mhdr: *const msghdr) -> *mut cmsghdr {","highlight_start":1,"highlight_end":64},{"text":"        if (*mhdr).msg_controllen as usize >= mem::size_of::<cmsghdr>() {","highlight_start":1,"highlight_end":74},{"text":"            (*mhdr).msg_control as *mut cmsghdr","highlight_start":1,"highlight_end":48},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"            0 as *mut cmsghdr","highlight_start":1,"highlight_end":30},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CMSG_DATA(cmsg: *const cmsghdr) -> *mut c_uchar {","highlight_start":1,"highlight_end":61},{"text":"        cmsg.offset(1) as *mut c_uchar","highlight_start":1,"highlight_end":39},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn CMSG_SPACE(length: c_uint) -> c_uint {","highlight_start":1,"highlight_end":58},{"text":"        (CMSG_ALIGN(length as usize) + CMSG_ALIGN(mem::size_of::<cmsghdr>())) as c_uint","highlight_start":1,"highlight_end":88},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn CMSG_LEN(length: c_uint) -> c_uint {","highlight_start":1,"highlight_end":56},{"text":"        CMSG_ALIGN(mem::size_of::<cmsghdr>()) as c_uint + length","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn FD_CLR(fd: c_int, set: *mut fd_set) -> () {","highlight_start":1,"highlight_end":55},{"text":"        let fd = fd as usize;","highlight_start":1,"highlight_end":30},{"text":"        let size = mem::size_of_val(&(*set).fds_bits[0]) * 8;","highlight_start":1,"highlight_end":62},{"text":"        (*set).fds_bits[fd / size] &= !(1 << (fd % size));","highlight_start":1,"highlight_end":59},{"text":"        return;","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn FD_ISSET(fd: c_int, set: *const fd_set) -> bool {","highlight_start":1,"highlight_end":61},{"text":"        let fd = fd as usize;","highlight_start":1,"highlight_end":30},{"text":"        let size = mem::size_of_val(&(*set).fds_bits[0]) * 8;","highlight_start":1,"highlight_end":62},{"text":"        return ((*set).fds_bits[fd / size] & (1 << (fd % size))) != 0;","highlight_start":1,"highlight_end":71},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn FD_SET(fd: c_int, set: *mut fd_set) -> () {","highlight_start":1,"highlight_end":55},{"text":"        let fd = fd as usize;","highlight_start":1,"highlight_end":30},{"text":"        let size = mem::size_of_val(&(*set).fds_bits[0]) * 8;","highlight_start":1,"highlight_end":62},{"text":"        (*set).fds_bits[fd / size] |= 1 << (fd % size);","highlight_start":1,"highlight_end":56},{"text":"        return;","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn FD_ZERO(set: *mut fd_set) -> () {","highlight_start":1,"highlight_end":45},{"text":"        for slot in (*set).fds_bits.iter_mut() {","highlight_start":1,"highlight_end":49},{"text":"            *slot = 0;","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"f!","def_site_span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":8546,"byte_end":8560,"line_start":238,"line_end":238,"column_start":9,"column_end":23,"is_primary":false,"text":[{"text":"        macro_rules! f {","highlight_start":9,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"explicitly specify the C ABI","code":null,"level":"help","spans":[{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":8865,"byte_end":8871,"line_start":246,"line_end":246,"column_start":43,"column_end":49,"is_primary":true,"text":[{"text":"                pub $($constness)* unsafe extern fn $i($($arg: $argty),*) -> $ret","highlight_start":43,"highlight_end":49}],"label":null,"suggested_replacement":"extern \"C\"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/linux_like/mod.rs","byte_start":56826,"byte_end":58289,"line_start":1614,"line_end":1660,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"f! {","highlight_start":1,"highlight_end":5},{"text":"    pub fn CMSG_FIRSTHDR(mhdr: *const msghdr) -> *mut cmsghdr {","highlight_start":1,"highlight_end":64},{"text":"        if (*mhdr).msg_controllen as usize >= mem::size_of::<cmsghdr>() {","highlight_start":1,"highlight_end":74},{"text":"            (*mhdr).msg_control as *mut cmsghdr","highlight_start":1,"highlight_end":48},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"            0 as *mut cmsghdr","highlight_start":1,"highlight_end":30},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CMSG_DATA(cmsg: *const cmsghdr) -> *mut c_uchar {","highlight_start":1,"highlight_end":61},{"text":"        cmsg.offset(1) as *mut c_uchar","highlight_start":1,"highlight_end":39},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn CMSG_SPACE(length: c_uint) -> c_uint {","highlight_start":1,"highlight_end":58},{"text":"        (CMSG_ALIGN(length as usize) + CMSG_ALIGN(mem::size_of::<cmsghdr>())) as c_uint","highlight_start":1,"highlight_end":88},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn CMSG_LEN(length: c_uint) -> c_uint {","highlight_start":1,"highlight_end":56},{"text":"        CMSG_ALIGN(mem::size_of::<cmsghdr>()) as c_uint + length","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn FD_CLR(fd: c_int, set: *mut fd_set) -> () {","highlight_start":1,"highlight_end":55},{"text":"        let fd = fd as usize;","highlight_start":1,"highlight_end":30},{"text":"        let size = mem::size_of_val(&(*set).fds_bits[0]) * 8;","highlight_start":1,"highlight_end":62},{"text":"        (*set).fds_bits[fd / size] &= !(1 << (fd % size));","highlight_start":1,"highlight_end":59},{"text":"        return;","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn FD_ISSET(fd: c_int, set: *const fd_set) -> bool {","highlight_start":1,"highlight_end":61},{"text":"        let fd = fd as usize;","highlight_start":1,"highlight_end":30},{"text":"        let size = mem::size_of_val(&(*set).fds_bits[0]) * 8;","highlight_start":1,"highlight_end":62},{"text":"        return ((*set).fds_bits[fd / size] & (1 << (fd % size))) != 0;","highlight_start":1,"highlight_end":71},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn FD_SET(fd: c_int, set: *mut fd_set) -> () {","highlight_start":1,"highlight_end":55},{"text":"        let fd = fd as usize;","highlight_start":1,"highlight_end":30},{"text":"        let size = mem::size_of_val(&(*set).fds_bits[0]) * 8;","highlight_start":1,"highlight_end":62},{"text":"        (*set).fds_bits[fd / size] |= 1 << (fd % size);","highlight_start":1,"highlight_end":56},{"text":"        return;","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn FD_ZERO(set: *mut fd_set) -> () {","highlight_start":1,"highlight_end":45},{"text":"        for slot in (*set).fds_bits.iter_mut() {","highlight_start":1,"highlight_end":49},{"text":"            *slot = 0;","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"f!","def_site_span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":8546,"byte_end":8560,"line_start":238,"line_end":238,"column_start":9,"column_end":23,"is_primary":false,"text":[{"text":"        macro_rules! f {","highlight_start":9,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: extern declarations without an explicit ABI are deprecated\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs:246:43\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m246\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m($constness)* unsafe extern fn $i($($arg: $argty),*) -> $ret\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: explicitly specify the C ABI: `extern \"C\"`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/linux_like/mod.rs:1614:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1614\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mf! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1615\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn CMSG_FIRSTHDR(mhdr: *const msghdr) -> *mut cmsghdr {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1616\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if (*mhdr).msg_controllen as usize >= mem::size_of::\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1617\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            (*mhdr).msg_control as *mut cmsghdr\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1660\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `f` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"extern declarations without an explicit ABI are deprecated","code":{"code":"missing_abi","explanation":null},"level":"warning","spans":[{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":9378,"byte_end":9384,"line_start":260,"line_end":260,"column_start":36,"column_end":42,"is_primary":true,"text":[{"text":"                pub $($constness)* extern fn $i($($arg: $argty),*) -> $ret","highlight_start":36,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/linux_like/mod.rs","byte_start":58291,"byte_end":60068,"line_start":1662,"line_end":1739,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"safe_f! {","highlight_start":1,"highlight_end":10},{"text":"    pub fn SIGRTMAX() -> c_int {","highlight_start":1,"highlight_end":33},{"text":"        unsafe { __libc_current_sigrtmax() }","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn SIGRTMIN() -> c_int {","highlight_start":1,"highlight_end":33},{"text":"        unsafe { __libc_current_sigrtmin() }","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WIFSTOPPED(status: c_int) -> bool {","highlight_start":1,"highlight_end":55},{"text":"        (status & 0xff) == 0x7f","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WSTOPSIG(status: c_int) -> c_int {","highlight_start":1,"highlight_end":54},{"text":"        (status >> 8) & 0xff","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WIFCONTINUED(status: c_int) -> bool {","highlight_start":1,"highlight_end":57},{"text":"        status == 0xffff","highlight_start":1,"highlight_end":25},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WIFSIGNALED(status: c_int) -> bool {","highlight_start":1,"highlight_end":56},{"text":"        ((status & 0x7f) + 1) as i8 >= 2","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WTERMSIG(status: c_int) -> c_int {","highlight_start":1,"highlight_end":54},{"text":"        status & 0x7f","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WIFEXITED(status: c_int) -> bool {","highlight_start":1,"highlight_end":54},{"text":"        (status & 0x7f) == 0","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WEXITSTATUS(status: c_int) -> c_int {","highlight_start":1,"highlight_end":57},{"text":"        (status >> 8) & 0xff","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WCOREDUMP(status: c_int) -> bool {","highlight_start":1,"highlight_end":54},{"text":"        (status & 0x80) != 0","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn W_EXITCODE(ret: c_int, sig: c_int) -> c_int {","highlight_start":1,"highlight_end":65},{"text":"        (ret << 8) | sig","highlight_start":1,"highlight_end":25},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn W_STOPCODE(sig: c_int) -> c_int {","highlight_start":1,"highlight_end":53},{"text":"        (sig << 8) | 0x7f","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn QCMD(cmd: c_int, type_: c_int) -> c_int {","highlight_start":1,"highlight_end":61},{"text":"        (cmd << 8) | (type_ & 0x00ff)","highlight_start":1,"highlight_end":38},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn IPOPT_COPIED(o: u8) -> u8 {","highlight_start":1,"highlight_end":47},{"text":"        o & IPOPT_COPY","highlight_start":1,"highlight_end":23},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn IPOPT_CLASS(o: u8) -> u8 {","highlight_start":1,"highlight_end":46},{"text":"        o & IPOPT_CLASS_MASK","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn IPOPT_NUMBER(o: u8) -> u8 {","highlight_start":1,"highlight_end":47},{"text":"        o & IPOPT_NUMBER_MASK","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn IPTOS_ECN(x: u8) -> u8 {","highlight_start":1,"highlight_end":44},{"text":"        x & crate::IPTOS_ECN_MASK","highlight_start":1,"highlight_end":34},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[allow(ellipsis_inclusive_range_patterns)]","highlight_start":1,"highlight_end":48},{"text":"    pub {const} fn KERNEL_VERSION(a: u32, b: u32, c: u32) -> u32 {","highlight_start":1,"highlight_end":67},{"text":"        ((a << 16) + (b << 8))","highlight_start":1,"highlight_end":31},{"text":"            + match c {","highlight_start":1,"highlight_end":24},{"text":"                0..=255 => c,","highlight_start":1,"highlight_end":30},{"text":"                _ => 255,","highlight_start":1,"highlight_end":26},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"safe_f!","def_site_span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":9061,"byte_end":9080,"line_start":252,"line_end":252,"column_start":9,"column_end":28,"is_primary":false,"text":[{"text":"        macro_rules! safe_f {","highlight_start":9,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"explicitly specify the C ABI","code":null,"level":"help","spans":[{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":9378,"byte_end":9384,"line_start":260,"line_end":260,"column_start":36,"column_end":42,"is_primary":true,"text":[{"text":"                pub $($constness)* extern fn $i($($arg: $argty),*) -> $ret","highlight_start":36,"highlight_end":42}],"label":null,"suggested_replacement":"extern \"C\"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/linux_like/mod.rs","byte_start":58291,"byte_end":60068,"line_start":1662,"line_end":1739,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"safe_f! {","highlight_start":1,"highlight_end":10},{"text":"    pub fn SIGRTMAX() -> c_int {","highlight_start":1,"highlight_end":33},{"text":"        unsafe { __libc_current_sigrtmax() }","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn SIGRTMIN() -> c_int {","highlight_start":1,"highlight_end":33},{"text":"        unsafe { __libc_current_sigrtmin() }","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WIFSTOPPED(status: c_int) -> bool {","highlight_start":1,"highlight_end":55},{"text":"        (status & 0xff) == 0x7f","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WSTOPSIG(status: c_int) -> c_int {","highlight_start":1,"highlight_end":54},{"text":"        (status >> 8) & 0xff","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WIFCONTINUED(status: c_int) -> bool {","highlight_start":1,"highlight_end":57},{"text":"        status == 0xffff","highlight_start":1,"highlight_end":25},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WIFSIGNALED(status: c_int) -> bool {","highlight_start":1,"highlight_end":56},{"text":"        ((status & 0x7f) + 1) as i8 >= 2","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WTERMSIG(status: c_int) -> c_int {","highlight_start":1,"highlight_end":54},{"text":"        status & 0x7f","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WIFEXITED(status: c_int) -> bool {","highlight_start":1,"highlight_end":54},{"text":"        (status & 0x7f) == 0","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WEXITSTATUS(status: c_int) -> c_int {","highlight_start":1,"highlight_end":57},{"text":"        (status >> 8) & 0xff","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn WCOREDUMP(status: c_int) -> bool {","highlight_start":1,"highlight_end":54},{"text":"        (status & 0x80) != 0","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn W_EXITCODE(ret: c_int, sig: c_int) -> c_int {","highlight_start":1,"highlight_end":65},{"text":"        (ret << 8) | sig","highlight_start":1,"highlight_end":25},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn W_STOPCODE(sig: c_int) -> c_int {","highlight_start":1,"highlight_end":53},{"text":"        (sig << 8) | 0x7f","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn QCMD(cmd: c_int, type_: c_int) -> c_int {","highlight_start":1,"highlight_end":61},{"text":"        (cmd << 8) | (type_ & 0x00ff)","highlight_start":1,"highlight_end":38},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn IPOPT_COPIED(o: u8) -> u8 {","highlight_start":1,"highlight_end":47},{"text":"        o & IPOPT_COPY","highlight_start":1,"highlight_end":23},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn IPOPT_CLASS(o: u8) -> u8 {","highlight_start":1,"highlight_end":46},{"text":"        o & IPOPT_CLASS_MASK","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn IPOPT_NUMBER(o: u8) -> u8 {","highlight_start":1,"highlight_end":47},{"text":"        o & IPOPT_NUMBER_MASK","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn IPTOS_ECN(x: u8) -> u8 {","highlight_start":1,"highlight_end":44},{"text":"        x & crate::IPTOS_ECN_MASK","highlight_start":1,"highlight_end":34},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    #[allow(ellipsis_inclusive_range_patterns)]","highlight_start":1,"highlight_end":48},{"text":"    pub {const} fn KERNEL_VERSION(a: u32, b: u32, c: u32) -> u32 {","highlight_start":1,"highlight_end":67},{"text":"        ((a << 16) + (b << 8))","highlight_start":1,"highlight_end":31},{"text":"            + match c {","highlight_start":1,"highlight_end":24},{"text":"                0..=255 => c,","highlight_start":1,"highlight_end":30},{"text":"                _ => 255,","highlight_start":1,"highlight_end":26},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"safe_f!","def_site_span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":9061,"byte_end":9080,"line_start":252,"line_end":252,"column_start":9,"column_end":28,"is_primary":false,"text":[{"text":"        macro_rules! safe_f {","highlight_start":9,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: extern declarations without an explicit ABI are deprecated\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs:260:36\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m260\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  pub $($constness)* extern fn $i($($arg: $argty),*) -> $ret\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: explicitly specify the C ABI: `extern \"C\"`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/linux_like/mod.rs:1662:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1662\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0msafe_f! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1663\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn SIGRTMAX() -> c_int {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1664\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        unsafe { __libc_current_sigrtmax() }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1739\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `safe_f` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"extern declarations without an explicit ABI are deprecated","code":{"code":"missing_abi","explanation":null},"level":"warning","spans":[{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":8865,"byte_end":8871,"line_start":246,"line_end":246,"column_start":43,"column_end":49,"is_primary":true,"text":[{"text":"                pub $($constness)* unsafe extern fn $i($($arg: $argty),*) -> $ret","highlight_start":43,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/linux_like/linux/mod.rs","byte_start":193969,"byte_end":198876,"line_start":5804,"line_end":5978,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"f! {","highlight_start":1,"highlight_end":5},{"text":"    pub fn NLA_ALIGN(len: c_int) -> c_int {","highlight_start":1,"highlight_end":44},{"text":"        return ((len) + NLA_ALIGNTO - 1) & !(NLA_ALIGNTO - 1);","highlight_start":1,"highlight_end":63},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CMSG_NXTHDR(mhdr: *const msghdr, cmsg: *const cmsghdr) -> *mut cmsghdr {","highlight_start":1,"highlight_end":84},{"text":"        if ((*cmsg).cmsg_len as usize) < size_of::<cmsghdr>() {","highlight_start":1,"highlight_end":64},{"text":"            return 0 as *mut cmsghdr;","highlight_start":1,"highlight_end":38},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        let next = (cmsg as usize + super::CMSG_ALIGN((*cmsg).cmsg_len as usize)) as *mut cmsghdr;","highlight_start":1,"highlight_end":99},{"text":"        let max = (*mhdr).msg_control as usize + (*mhdr).msg_controllen as usize;","highlight_start":1,"highlight_end":82},{"text":"        if (next.wrapping_offset(1)) as usize > max","highlight_start":1,"highlight_end":52},{"text":"            || next as usize + super::CMSG_ALIGN((*next).cmsg_len as usize) > max","highlight_start":1,"highlight_end":82},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            0 as *mut cmsghdr","highlight_start":1,"highlight_end":30},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"            next as *mut cmsghdr","highlight_start":1,"highlight_end":33},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_ALLOC_SIZE(count: c_int) -> size_t {","highlight_start":1,"highlight_end":52},{"text":"        let _dummy: cpu_set_t = mem::zeroed();","highlight_start":1,"highlight_end":47},{"text":"        let size_in_bits = 8 * mem::size_of_val(&_dummy.bits[0]);","highlight_start":1,"highlight_end":66},{"text":"        ((count as size_t + size_in_bits - 1) / 8) as size_t","highlight_start":1,"highlight_end":61},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_ZERO(cpuset: &mut cpu_set_t) -> () {","highlight_start":1,"highlight_end":52},{"text":"        for slot in cpuset.bits.iter_mut() {","highlight_start":1,"highlight_end":45},{"text":"            *slot = 0;","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_SET(cpu: usize, cpuset: &mut cpu_set_t) -> () {","highlight_start":1,"highlight_end":63},{"text":"        let size_in_bits = 8 * mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc","highlight_start":1,"highlight_end":80},{"text":"        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);","highlight_start":1,"highlight_end":70},{"text":"        cpuset.bits[idx] |= 1 << offset;","highlight_start":1,"highlight_end":41},{"text":"        ()","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_CLR(cpu: usize, cpuset: &mut cpu_set_t) -> () {","highlight_start":1,"highlight_end":63},{"text":"        let size_in_bits = 8 * mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc","highlight_start":1,"highlight_end":80},{"text":"        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);","highlight_start":1,"highlight_end":70},{"text":"        cpuset.bits[idx] &= !(1 << offset);","highlight_start":1,"highlight_end":44},{"text":"        ()","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_ISSET(cpu: usize, cpuset: &cpu_set_t) -> bool {","highlight_start":1,"highlight_end":63},{"text":"        let size_in_bits = 8 * mem::size_of_val(&cpuset.bits[0]);","highlight_start":1,"highlight_end":66},{"text":"        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);","highlight_start":1,"highlight_end":70},{"text":"        0 != (cpuset.bits[idx] & (1 << offset))","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_COUNT_S(size: usize, cpuset: &cpu_set_t) -> c_int {","highlight_start":1,"highlight_end":67},{"text":"        let mut s: u32 = 0;","highlight_start":1,"highlight_end":28},{"text":"        let size_of_mask = mem::size_of_val(&cpuset.bits[0]);","highlight_start":1,"highlight_end":62},{"text":"        for i in cpuset.bits[..(size / size_of_mask)].iter() {","highlight_start":1,"highlight_end":63},{"text":"            s += i.count_ones();","highlight_start":1,"highlight_end":33},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        s as c_int","highlight_start":1,"highlight_end":19},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_COUNT(cpuset: &cpu_set_t) -> c_int {","highlight_start":1,"highlight_end":52},{"text":"        CPU_COUNT_S(size_of::<cpu_set_t>(), cpuset)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_EQUAL(set1: &cpu_set_t, set2: &cpu_set_t) -> bool {","highlight_start":1,"highlight_end":67},{"text":"        set1.bits == set2.bits","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn SCTP_PR_INDEX(policy: c_int) -> c_int {","highlight_start":1,"highlight_end":51},{"text":"        policy >> 4 - 1","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn SCTP_PR_POLICY(policy: c_int) -> c_int {","highlight_start":1,"highlight_end":52},{"text":"        policy & SCTP_PR_SCTP_MASK","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn SCTP_PR_SET_POLICY(flags: &mut c_int, policy: c_int) -> () {","highlight_start":1,"highlight_end":72},{"text":"        *flags &= !SCTP_PR_SCTP_MASK;","highlight_start":1,"highlight_end":38},{"text":"        *flags |= policy;","highlight_start":1,"highlight_end":26},{"text":"        ()","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn major(dev: crate::dev_t) -> c_uint {","highlight_start":1,"highlight_end":48},{"text":"        let mut major = 0;","highlight_start":1,"highlight_end":27},{"text":"        major |= (dev & 0x00000000000fff00) >> 8;","highlight_start":1,"highlight_end":50},{"text":"        major |= (dev & 0xfffff00000000000) >> 32;","highlight_start":1,"highlight_end":51},{"text":"        major as c_uint","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn minor(dev: crate::dev_t) -> c_uint {","highlight_start":1,"highlight_end":48},{"text":"        let mut minor = 0;","highlight_start":1,"highlight_end":27},{"text":"        minor |= (dev & 0x00000000000000ff) >> 0;","highlight_start":1,"highlight_end":50},{"text":"        minor |= (dev & 0x00000ffffff00000) >> 12;","highlight_start":1,"highlight_end":51},{"text":"        minor as c_uint","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn IPTOS_TOS(tos: u8) -> u8 {","highlight_start":1,"highlight_end":38},{"text":"        tos & IPTOS_TOS_MASK","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn IPTOS_PREC(tos: u8) -> u8 {","highlight_start":1,"highlight_end":39},{"text":"        tos & IPTOS_PREC_MASK","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn RT_TOS(tos: u8) -> u8 {","highlight_start":1,"highlight_end":35},{"text":"        tos & crate::IPTOS_TOS_MASK","highlight_start":1,"highlight_end":36},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn RT_ADDRCLASS(flags: u32) -> u32 {","highlight_start":1,"highlight_end":45},{"text":"        flags >> 23","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn RT_LOCALADDR(flags: u32) -> bool {","highlight_start":1,"highlight_end":46},{"text":"        (flags & RTF_ADDRCLASSMASK) == (RTF_LOCAL | RTF_INTERFACE)","highlight_start":1,"highlight_end":67},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn SO_EE_OFFENDER(ee: *const crate::sock_extended_err) -> *mut crate::sockaddr {","highlight_start":1,"highlight_end":89},{"text":"        ee.offset(1) as *mut crate::sockaddr","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn TPACKET_ALIGN(x: usize) -> usize {","highlight_start":1,"highlight_end":46},{"text":"        (x + TPACKET_ALIGNMENT - 1) & !(TPACKET_ALIGNMENT - 1)","highlight_start":1,"highlight_end":63},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn BPF_RVAL(code: __u32) -> __u32 {","highlight_start":1,"highlight_end":44},{"text":"        code & 0x18","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn BPF_MISCOP(code: __u32) -> __u32 {","highlight_start":1,"highlight_end":46},{"text":"        code & 0xf8","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn BPF_STMT(code: __u16, k: __u32) -> sock_filter {","highlight_start":1,"highlight_end":60},{"text":"        sock_filter {","highlight_start":1,"highlight_end":22},{"text":"            code: code,","highlight_start":1,"highlight_end":24},{"text":"            jt: 0,","highlight_start":1,"highlight_end":19},{"text":"            jf: 0,","highlight_start":1,"highlight_end":19},{"text":"            k: k,","highlight_start":1,"highlight_end":18},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn BPF_JUMP(code: __u16, k: __u32, jt: __u8, jf: __u8) -> sock_filter {","highlight_start":1,"highlight_end":80},{"text":"        sock_filter {","highlight_start":1,"highlight_end":22},{"text":"            code: code,","highlight_start":1,"highlight_end":24},{"text":"            jt: jt,","highlight_start":1,"highlight_end":20},{"text":"            jf: jf,","highlight_start":1,"highlight_end":20},{"text":"            k: k,","highlight_start":1,"highlight_end":18},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn ELF32_R_SYM(val: Elf32_Word) -> Elf32_Word {","highlight_start":1,"highlight_end":56},{"text":"        val >> 8","highlight_start":1,"highlight_end":17},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn ELF32_R_TYPE(val: Elf32_Word) -> Elf32_Word {","highlight_start":1,"highlight_end":57},{"text":"        val & 0xff","highlight_start":1,"highlight_end":19},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn ELF32_R_INFO(sym: Elf32_Word, t: Elf32_Word) -> Elf32_Word {","highlight_start":1,"highlight_end":72},{"text":"        sym << 8 + t & 0xff","highlight_start":1,"highlight_end":28},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn ELF64_R_SYM(val: Elf64_Xword) -> Elf64_Xword {","highlight_start":1,"highlight_end":58},{"text":"        val >> 32","highlight_start":1,"highlight_end":18},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn ELF64_R_TYPE(val: Elf64_Xword) -> Elf64_Xword {","highlight_start":1,"highlight_end":59},{"text":"        val & 0xffffffff","highlight_start":1,"highlight_end":25},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn ELF64_R_INFO(sym: Elf64_Xword, t: Elf64_Xword) -> Elf64_Xword {","highlight_start":1,"highlight_end":75},{"text":"        sym << 32 + t","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"f!","def_site_span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":8546,"byte_end":8560,"line_start":238,"line_end":238,"column_start":9,"column_end":23,"is_primary":false,"text":[{"text":"        macro_rules! f {","highlight_start":9,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"explicitly specify the C ABI","code":null,"level":"help","spans":[{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":8865,"byte_end":8871,"line_start":246,"line_end":246,"column_start":43,"column_end":49,"is_primary":true,"text":[{"text":"                pub $($constness)* unsafe extern fn $i($($arg: $argty),*) -> $ret","highlight_start":43,"highlight_end":49}],"label":null,"suggested_replacement":"extern \"C\"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/linux_like/linux/mod.rs","byte_start":193969,"byte_end":198876,"line_start":5804,"line_end":5978,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"f! {","highlight_start":1,"highlight_end":5},{"text":"    pub fn NLA_ALIGN(len: c_int) -> c_int {","highlight_start":1,"highlight_end":44},{"text":"        return ((len) + NLA_ALIGNTO - 1) & !(NLA_ALIGNTO - 1);","highlight_start":1,"highlight_end":63},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CMSG_NXTHDR(mhdr: *const msghdr, cmsg: *const cmsghdr) -> *mut cmsghdr {","highlight_start":1,"highlight_end":84},{"text":"        if ((*cmsg).cmsg_len as usize) < size_of::<cmsghdr>() {","highlight_start":1,"highlight_end":64},{"text":"            return 0 as *mut cmsghdr;","highlight_start":1,"highlight_end":38},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        let next = (cmsg as usize + super::CMSG_ALIGN((*cmsg).cmsg_len as usize)) as *mut cmsghdr;","highlight_start":1,"highlight_end":99},{"text":"        let max = (*mhdr).msg_control as usize + (*mhdr).msg_controllen as usize;","highlight_start":1,"highlight_end":82},{"text":"        if (next.wrapping_offset(1)) as usize > max","highlight_start":1,"highlight_end":52},{"text":"            || next as usize + super::CMSG_ALIGN((*next).cmsg_len as usize) > max","highlight_start":1,"highlight_end":82},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            0 as *mut cmsghdr","highlight_start":1,"highlight_end":30},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"            next as *mut cmsghdr","highlight_start":1,"highlight_end":33},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_ALLOC_SIZE(count: c_int) -> size_t {","highlight_start":1,"highlight_end":52},{"text":"        let _dummy: cpu_set_t = mem::zeroed();","highlight_start":1,"highlight_end":47},{"text":"        let size_in_bits = 8 * mem::size_of_val(&_dummy.bits[0]);","highlight_start":1,"highlight_end":66},{"text":"        ((count as size_t + size_in_bits - 1) / 8) as size_t","highlight_start":1,"highlight_end":61},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_ZERO(cpuset: &mut cpu_set_t) -> () {","highlight_start":1,"highlight_end":52},{"text":"        for slot in cpuset.bits.iter_mut() {","highlight_start":1,"highlight_end":45},{"text":"            *slot = 0;","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_SET(cpu: usize, cpuset: &mut cpu_set_t) -> () {","highlight_start":1,"highlight_end":63},{"text":"        let size_in_bits = 8 * mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc","highlight_start":1,"highlight_end":80},{"text":"        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);","highlight_start":1,"highlight_end":70},{"text":"        cpuset.bits[idx] |= 1 << offset;","highlight_start":1,"highlight_end":41},{"text":"        ()","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_CLR(cpu: usize, cpuset: &mut cpu_set_t) -> () {","highlight_start":1,"highlight_end":63},{"text":"        let size_in_bits = 8 * mem::size_of_val(&cpuset.bits[0]); // 32, 64 etc","highlight_start":1,"highlight_end":80},{"text":"        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);","highlight_start":1,"highlight_end":70},{"text":"        cpuset.bits[idx] &= !(1 << offset);","highlight_start":1,"highlight_end":44},{"text":"        ()","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_ISSET(cpu: usize, cpuset: &cpu_set_t) -> bool {","highlight_start":1,"highlight_end":63},{"text":"        let size_in_bits = 8 * mem::size_of_val(&cpuset.bits[0]);","highlight_start":1,"highlight_end":66},{"text":"        let (idx, offset) = (cpu / size_in_bits, cpu % size_in_bits);","highlight_start":1,"highlight_end":70},{"text":"        0 != (cpuset.bits[idx] & (1 << offset))","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_COUNT_S(size: usize, cpuset: &cpu_set_t) -> c_int {","highlight_start":1,"highlight_end":67},{"text":"        let mut s: u32 = 0;","highlight_start":1,"highlight_end":28},{"text":"        let size_of_mask = mem::size_of_val(&cpuset.bits[0]);","highlight_start":1,"highlight_end":62},{"text":"        for i in cpuset.bits[..(size / size_of_mask)].iter() {","highlight_start":1,"highlight_end":63},{"text":"            s += i.count_ones();","highlight_start":1,"highlight_end":33},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        s as c_int","highlight_start":1,"highlight_end":19},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_COUNT(cpuset: &cpu_set_t) -> c_int {","highlight_start":1,"highlight_end":52},{"text":"        CPU_COUNT_S(size_of::<cpu_set_t>(), cpuset)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn CPU_EQUAL(set1: &cpu_set_t, set2: &cpu_set_t) -> bool {","highlight_start":1,"highlight_end":67},{"text":"        set1.bits == set2.bits","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn SCTP_PR_INDEX(policy: c_int) -> c_int {","highlight_start":1,"highlight_end":51},{"text":"        policy >> 4 - 1","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn SCTP_PR_POLICY(policy: c_int) -> c_int {","highlight_start":1,"highlight_end":52},{"text":"        policy & SCTP_PR_SCTP_MASK","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn SCTP_PR_SET_POLICY(flags: &mut c_int, policy: c_int) -> () {","highlight_start":1,"highlight_end":72},{"text":"        *flags &= !SCTP_PR_SCTP_MASK;","highlight_start":1,"highlight_end":38},{"text":"        *flags |= policy;","highlight_start":1,"highlight_end":26},{"text":"        ()","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn major(dev: crate::dev_t) -> c_uint {","highlight_start":1,"highlight_end":48},{"text":"        let mut major = 0;","highlight_start":1,"highlight_end":27},{"text":"        major |= (dev & 0x00000000000fff00) >> 8;","highlight_start":1,"highlight_end":50},{"text":"        major |= (dev & 0xfffff00000000000) >> 32;","highlight_start":1,"highlight_end":51},{"text":"        major as c_uint","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn minor(dev: crate::dev_t) -> c_uint {","highlight_start":1,"highlight_end":48},{"text":"        let mut minor = 0;","highlight_start":1,"highlight_end":27},{"text":"        minor |= (dev & 0x00000000000000ff) >> 0;","highlight_start":1,"highlight_end":50},{"text":"        minor |= (dev & 0x00000ffffff00000) >> 12;","highlight_start":1,"highlight_end":51},{"text":"        minor as c_uint","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn IPTOS_TOS(tos: u8) -> u8 {","highlight_start":1,"highlight_end":38},{"text":"        tos & IPTOS_TOS_MASK","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn IPTOS_PREC(tos: u8) -> u8 {","highlight_start":1,"highlight_end":39},{"text":"        tos & IPTOS_PREC_MASK","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn RT_TOS(tos: u8) -> u8 {","highlight_start":1,"highlight_end":35},{"text":"        tos & crate::IPTOS_TOS_MASK","highlight_start":1,"highlight_end":36},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn RT_ADDRCLASS(flags: u32) -> u32 {","highlight_start":1,"highlight_end":45},{"text":"        flags >> 23","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn RT_LOCALADDR(flags: u32) -> bool {","highlight_start":1,"highlight_end":46},{"text":"        (flags & RTF_ADDRCLASSMASK) == (RTF_LOCAL | RTF_INTERFACE)","highlight_start":1,"highlight_end":67},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn SO_EE_OFFENDER(ee: *const crate::sock_extended_err) -> *mut crate::sockaddr {","highlight_start":1,"highlight_end":89},{"text":"        ee.offset(1) as *mut crate::sockaddr","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn TPACKET_ALIGN(x: usize) -> usize {","highlight_start":1,"highlight_end":46},{"text":"        (x + TPACKET_ALIGNMENT - 1) & !(TPACKET_ALIGNMENT - 1)","highlight_start":1,"highlight_end":63},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn BPF_RVAL(code: __u32) -> __u32 {","highlight_start":1,"highlight_end":44},{"text":"        code & 0x18","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn BPF_MISCOP(code: __u32) -> __u32 {","highlight_start":1,"highlight_end":46},{"text":"        code & 0xf8","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn BPF_STMT(code: __u16, k: __u32) -> sock_filter {","highlight_start":1,"highlight_end":60},{"text":"        sock_filter {","highlight_start":1,"highlight_end":22},{"text":"            code: code,","highlight_start":1,"highlight_end":24},{"text":"            jt: 0,","highlight_start":1,"highlight_end":19},{"text":"            jf: 0,","highlight_start":1,"highlight_end":19},{"text":"            k: k,","highlight_start":1,"highlight_end":18},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn BPF_JUMP(code: __u16, k: __u32, jt: __u8, jf: __u8) -> sock_filter {","highlight_start":1,"highlight_end":80},{"text":"        sock_filter {","highlight_start":1,"highlight_end":22},{"text":"            code: code,","highlight_start":1,"highlight_end":24},{"text":"            jt: jt,","highlight_start":1,"highlight_end":20},{"text":"            jf: jf,","highlight_start":1,"highlight_end":20},{"text":"            k: k,","highlight_start":1,"highlight_end":18},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn ELF32_R_SYM(val: Elf32_Word) -> Elf32_Word {","highlight_start":1,"highlight_end":56},{"text":"        val >> 8","highlight_start":1,"highlight_end":17},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn ELF32_R_TYPE(val: Elf32_Word) -> Elf32_Word {","highlight_start":1,"highlight_end":57},{"text":"        val & 0xff","highlight_start":1,"highlight_end":19},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn ELF32_R_INFO(sym: Elf32_Word, t: Elf32_Word) -> Elf32_Word {","highlight_start":1,"highlight_end":72},{"text":"        sym << 8 + t & 0xff","highlight_start":1,"highlight_end":28},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn ELF64_R_SYM(val: Elf64_Xword) -> Elf64_Xword {","highlight_start":1,"highlight_end":58},{"text":"        val >> 32","highlight_start":1,"highlight_end":18},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn ELF64_R_TYPE(val: Elf64_Xword) -> Elf64_Xword {","highlight_start":1,"highlight_end":59},{"text":"        val & 0xffffffff","highlight_start":1,"highlight_end":25},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn ELF64_R_INFO(sym: Elf64_Xword, t: Elf64_Xword) -> Elf64_Xword {","highlight_start":1,"highlight_end":75},{"text":"        sym << 32 + t","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"f!","def_site_span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":8546,"byte_end":8560,"line_start":238,"line_end":238,"column_start":9,"column_end":23,"is_primary":false,"text":[{"text":"        macro_rules! f {","highlight_start":9,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: extern declarations without an explicit ABI are deprecated\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs:246:43\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m246\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m($constness)* unsafe extern fn $i($($arg: $argty),*) -> $ret\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: explicitly specify the C ABI: `extern \"C\"`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/linux_like/linux/mod.rs:5804:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5804\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mf! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5805\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn NLA_ALIGN(len: c_int) -> c_int {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5806\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        return ((len) + NLA_ALIGNTO - 1) & !(NLA_ALIGNTO - 1);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5978\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `f` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"extern declarations without an explicit ABI are deprecated","code":{"code":"missing_abi","explanation":null},"level":"warning","spans":[{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":9378,"byte_end":9384,"line_start":260,"line_end":260,"column_start":36,"column_end":42,"is_primary":true,"text":[{"text":"                pub $($constness)* extern fn $i($($arg: $argty),*) -> $ret","highlight_start":36,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/linux_like/linux/mod.rs","byte_start":198878,"byte_end":199583,"line_start":5980,"line_end":6003,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"safe_f! {","highlight_start":1,"highlight_end":10},{"text":"    pub {const} fn makedev(major: c_uint, minor: c_uint) -> crate::dev_t {","highlight_start":1,"highlight_end":75},{"text":"        let major = major as crate::dev_t;","highlight_start":1,"highlight_end":43},{"text":"        let minor = minor as crate::dev_t;","highlight_start":1,"highlight_end":43},{"text":"        let mut dev = 0;","highlight_start":1,"highlight_end":25},{"text":"        dev |= (major & 0x00000fff) << 8;","highlight_start":1,"highlight_end":42},{"text":"        dev |= (major & 0xfffff000) << 32;","highlight_start":1,"highlight_end":43},{"text":"        dev |= (minor & 0x000000ff) << 0;","highlight_start":1,"highlight_end":42},{"text":"        dev |= (minor & 0xffffff00) << 12;","highlight_start":1,"highlight_end":43},{"text":"        dev","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn SCTP_PR_TTL_ENABLED(policy: c_int) -> bool {","highlight_start":1,"highlight_end":64},{"text":"        policy == SCTP_PR_SCTP_TTL","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn SCTP_PR_RTX_ENABLED(policy: c_int) -> bool {","highlight_start":1,"highlight_end":64},{"text":"        policy == SCTP_PR_SCTP_RTX","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn SCTP_PR_PRIO_ENABLED(policy: c_int) -> bool {","highlight_start":1,"highlight_end":65},{"text":"        policy == SCTP_PR_SCTP_PRIO","highlight_start":1,"highlight_end":36},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"safe_f!","def_site_span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":9061,"byte_end":9080,"line_start":252,"line_end":252,"column_start":9,"column_end":28,"is_primary":false,"text":[{"text":"        macro_rules! safe_f {","highlight_start":9,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"explicitly specify the C ABI","code":null,"level":"help","spans":[{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":9378,"byte_end":9384,"line_start":260,"line_end":260,"column_start":36,"column_end":42,"is_primary":true,"text":[{"text":"                pub $($constness)* extern fn $i($($arg: $argty),*) -> $ret","highlight_start":36,"highlight_end":42}],"label":null,"suggested_replacement":"extern \"C\"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/linux_like/linux/mod.rs","byte_start":198878,"byte_end":199583,"line_start":5980,"line_end":6003,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"safe_f! {","highlight_start":1,"highlight_end":10},{"text":"    pub {const} fn makedev(major: c_uint, minor: c_uint) -> crate::dev_t {","highlight_start":1,"highlight_end":75},{"text":"        let major = major as crate::dev_t;","highlight_start":1,"highlight_end":43},{"text":"        let minor = minor as crate::dev_t;","highlight_start":1,"highlight_end":43},{"text":"        let mut dev = 0;","highlight_start":1,"highlight_end":25},{"text":"        dev |= (major & 0x00000fff) << 8;","highlight_start":1,"highlight_end":42},{"text":"        dev |= (major & 0xfffff000) << 32;","highlight_start":1,"highlight_end":43},{"text":"        dev |= (minor & 0x000000ff) << 0;","highlight_start":1,"highlight_end":42},{"text":"        dev |= (minor & 0xffffff00) << 12;","highlight_start":1,"highlight_end":43},{"text":"        dev","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn SCTP_PR_TTL_ENABLED(policy: c_int) -> bool {","highlight_start":1,"highlight_end":64},{"text":"        policy == SCTP_PR_SCTP_TTL","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn SCTP_PR_RTX_ENABLED(policy: c_int) -> bool {","highlight_start":1,"highlight_end":64},{"text":"        policy == SCTP_PR_SCTP_RTX","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub {const} fn SCTP_PR_PRIO_ENABLED(policy: c_int) -> bool {","highlight_start":1,"highlight_end":65},{"text":"        policy == SCTP_PR_SCTP_PRIO","highlight_start":1,"highlight_end":36},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"safe_f!","def_site_span":{"file_name":"/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs","byte_start":9061,"byte_end":9080,"line_start":252,"line_end":252,"column_start":9,"column_end":28,"is_primary":false,"text":[{"text":"        macro_rules! safe_f {","highlight_start":9,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: extern declarations without an explicit ABI are deprecated\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/macros.rs:260:36\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m260\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  pub $($constness)* extern fn $i($($arg: $argty),*) -> $ret\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: explicitly specify the C ABI: `extern \"C\"`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/misschiedu/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.169/src/unix/linux_like/linux/mod.rs:5980:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5980\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0msafe_f! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5981\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub {const} fn makedev(major: c_uint, minor: c_uint) -> \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5982\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let major = major as crate::dev_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5983\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let minor = minor as crate::dev_t;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6003\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `safe_f` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"5 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: 5 warnings emitted\u001b[0m\n\n"}
